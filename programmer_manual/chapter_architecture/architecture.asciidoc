== Architecture of abidos

Abidos have these main modules:
indexterm:[architecture]
indexterm:[design]

* loader
indexterm:[loader]

* lexical analyzer
indexterm:[lexical]

* syntactic analyzer
indexterm:[syntactic]

* semantic analyzer
indexterm:[semantic]

* symbols table
indexterm:[symbols]

* generators
indexterm:[generators]

** uml diagrams
** original code

* trace system

* dot viewer
indexterm:[dot viewer]

=== Loader
indexterm:[loader]

.c_loader UML diagram
image::out/images/chapter_architecture_c_loader_uml_01.{eps_svg}[align="center"]

=== lexer
indexterm:[lexer]

Explain lexer phase.

=== Parser
indexterm:[parser]

.c_parser UML diagram 1
image::out/images/chapter_architecture_c_parser_uml_01.{eps_svg}[align="center"]

c_context class is a *key part* of Abidos, for each node in the
*annotated parse tree*
indexterm:[c_context]

.c_parser UML diagram 2
image::out/images/chapter_architecture_c_parser_uml_02.{eps_svg}[align="center"]

Parser use this class all the time to get knowledge about tokens and too restore
states in the backtracking process.


=== symbols table

When Abidos are parsing a source C++ file; lexical analyzer give to syntactic
analyzer all the tokens founded in the source file, some of this tokens
are saved in the table symbols.

.c_symbols_table UML diagram 1
image::out/images/chapter_architecture_c_symbols_table_uml_01.{eps_svg}[align="center"]

.c_symbols_table c_declarator UML diagram 2
image::out/images/chapter_architecture_c_declarator_table_uml_01.{eps_svg}[align="center"]

Example
----
int a; <1>
----

<1> there are 3 tokens here: "int", "a" and ";"

Abidos when process this 3 tokens knows "a" is a variable and his type is "int"
one.

These identifiers are stored in a map

//## explain how c_token is transformed to a c_symbol

In computer programming, a scope is the context within a program in
which a variable name or other identifier is valid and can be used,
or within which a declaration has effect.

=== Saving context

Abidos uses c_context_tokens to store in which token has being parsing in the
begin of a syntactic rule.

c_context_tokens context_tokens(context);
indexterm:[context]

=== Trace system

Abidos when finishes the parsing process can generates a diagram tree with
the rules used, you should use it only with small examples. In c_parser_descent
you can see how all rules pass trace_node and add it to trace_graph

----
int c_parser_descent::extern_c(c_trace_node trace_node)
{
    trace_graph.add(trace_node, "extern_c"); <1>
...
}
----

<1> that is how trace system knows what rule has being called.

c_trace_graph trace_graph
indexterm:[c_trace_node]
indexterm:[c_trace_node]
indexterm:[c_trace_graph]
indexterm:[trace_graph]

Here is the output tree drawn by Abidos trace system for the previous example:

.trace tree example
image::out/images/chapter_architecture_examples_trace_book_01.cpp.{eps_svg}[align="center"]

Is a super-set of an *annotated parse tree* we can see the successfully
branches and the unsuccessfully.

indexterm:[annotated parse tree]
indexterm:[c_trace_node]

Nodes begin with _<number>_: is the order in which abidos have processed it.

Shape of nodes have these meanings:

* ellipsis, are non terminal rules, like this
----
declaration_seq:
	declaration
	| declaration_seq declaration
	;
----

* box, are rules when some terminal tokens are processed, it can have no
terminal rules too, perimeter line of nodes have these meanings:

1) dotted in this nodes the terminals not matched, for example in:
----
      _13_template_declaration
      [int is not TEMPLATE] <1>
----
<1> Abidos was trying to match "int" with the reserved word "TEMPLATE".
indexterm:[dotted]

//without this comment the next line are nested :-(
2) green line: in this nodes some terminals matched, for example in:
----
      _15_simple_declaration
      [; is ;] <1>
----
<1> Abidos was trying to match ";" with ";" and it matched.
indexterm:[green]


You can see parsing a little example like that generate a tree of more than 40
nodes, descent parsing is more inefficient than yacc parsing, but i will try
to improve this with pruning methods. And remember C++ is a complex grammar to
do in yacc because is a tough task write his grammar using LALR.

